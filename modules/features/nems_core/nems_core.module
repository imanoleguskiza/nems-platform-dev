<?php
/**
 * @file
 * Code for the NEMS core settings feature.
 */

include_once 'nems_core.features.inc';

define("NEMS_CORE_MBP_MEDIA_FOLDER_ROOT", "Media Root");
define("NEMS_CORE_MBP_MEDIA_FOLDER_VOCABULARY", "media_folders");
define("NEMS_CORE_BLOCK_ACCESS_ROLE", 6);
const NEMS_CORE_BLOCK_ACCESS_PERMISSIONS = array(
  'config',
  'config_body',
  'config_desc',
  'config_lang',
  'config_page_visibility',
  'config_region',
  'config_role_visibility',
  'config_title',
  'config_type_visibility',
  'config_user_visibility',
  'delete',
  'disable',
  'enable',
  'move',
  'view',
);

/**
 * Implements hook_permission().
 */
function nems_core_permission() {
  return array(
    'access nems menu' => array(
      'title' => t('NEMS Menu access'),
      'description' => t('Restrict the access to several menu items on the NEMS template.'),
    ),
    'access europa search' => array(
      'title' => t('Europa Search access'),
      'description' => t('Access the configuration of the Europa Search tool.'),
    ),

  );
}

/**
 * Implements hook_menu().
 */
function nems_core_menu() {
  $items = array();

  $items['admin/content/file/nems_core'] = array(
    'title' => 'Sync folders',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('nems_core_sync_folders_form'),
    'access arguments' => array('administer_files'),
    'type' => MENU_LOCAL_TASK,
  );
  return $items;
}

/**
 * Implements hook_menu_alter().
 */
function nems_core_menu_alter(&$items) {
  // List of menu items we will restrict access to.
  $path_list = array(
    'admin/config/content/ckeditor_tabber',
    'admin/config/administration/admin_menu',
    'admin/config/content/title',
    'admin/config/content/entityconnect',
    'admin/config/content/version_management/settings',
    'admin/config/media/file-system',
    'admin/config/media/file-system/transliteration',
    'admin/config/content/node_export',
    'admin/config/date/date_popup',
    'admin/config/development/strongarm',
    'admin/config/people/accounts',
    'admin/config/development/jquery_update',
    'admin/config/development/generate/user',
    'admin/config/menu_token',
    'admin/config/media/media_node',
    'admin/config/media/image-toolkit',
    'admin/config/media/colorbox',
    'admin/config/media/file-settings',
    'admin/config/regional/i18n',
    'admin/config/regional/language/configure',
    'admin/config/security/settings',
    'admin/config/system/nexteuropa-tokens',
    'admin/config/system/cron',
    'admin/config/user-interface/chosen',
    'admin/people/create',
    'admin/structure/block/add',
    'admin/config/regional/language/admin_language',
    'admin/config/regional/language/configure',
  );
  foreach ($path_list as $path) {
    if (isset($items[$path])) {
      if (isset($items[$path]['access callback'])) {
        unset($items[$path]['access callback']);
      }
      $items[$path]['access arguments'][0] = 'access nems menu';
    }
  }

  // Give access to menu block to users that can administer blocks.
  if (isset($items['admin/structure/block/add-menu-block'])) {
    $items['admin/structure/block/add-menu-block']['access callback'] = '_nems_core_menu_block_access';
  }

  // Restrict access to europa search.
  if (isset($items['admin/config/search/europa_search'])) {
    $items['admin/config/search/europa_search']['access arguments'][0] = 'access europa search';
  }
  // Add restrictions to access bartik and seven.
  if (isset($items['admin/structure/block/list/bartik'])) {
    $items['admin/structure/block/list/bartik']['access callback'] = '_nems_core_block_themes_access';
  }
  if (isset($items['admin/structure/block/list/seven'])) {
    $items['admin/structure/block/list/seven']['access callback'] = '_nems_core_block_themes_access';
  }

  // Restrict access to administrator users.
  $items['user/%user/edit']['access callback'] = '_nems_core_user_edit_access';
  $items['user/%user/cancel']['access callback'] = '_nems_core_user_edit_access';
}

/**
 * Determine whether the user has permission to use menu_block module.
 *
 * @param object $account
 *   Object containing account data.
 *
 * @return bool
 *   Access rights edit result.
 */
function _nems_core_menu_block_access($account = NULL) {
  return user_access('administer blocks', $account);
}

/**
 * Add access restrictions to a block.
 *
 * @param object $module
 *   Module that built the block.
 * @param object $delta
 *   Delta identifying the block.
 * @param bool $delete
 *   Flag to mark a deletion processs.
 */
function _nems_core_restrict_block_access($module, $delta, $delete = FALSE) {
  if (!$delete) {
    foreach (NEMS_CORE_BLOCK_ACCESS_PERMISSIONS as $permission) {
      db_insert('block_access_roles')
        ->fields(array(
          'module' => $module,
          'delta' => $delta,
          'rid' => NEMS_CORE_BLOCK_ACCESS_ROLE,
          'permission' => $permission,
        ))
        ->execute();
    }
  }
  else {
    foreach (NEMS_CORE_BLOCK_ACCESS_PERMISSIONS as $permission) {
      db_delete('block_access_roles')
        ->condition('module', $module)
        ->condition('delta', $delta)
        ->condition('rid', NEMS_CORE_BLOCK_ACCESS_ROLE)
        ->condition('permission', $permission)
        ->execute();
    }
  }
}

/**
 * Implements hook_features_api_alter().
 */
function nems_core_features_api_alter(&$components) {
  // We force block_access components to be processed
  // after roles have been added.
  if (isset($components['block_access'])) {
    $setting = $components['block_access'];
    unset($components['block_access']);
    $components['block_access'] = $setting;
  }
}

/**
 * Implements hook_block_view_alter().
 *
 * We hide bean blocks if blockreference is empty.
 */
function nems_core_block_view_alter(&$data, $block) {
  // Check if the block is a bean.
  if ($block->module == 'bean') {
    reset($data['content']['bean']);
    $bean = current($data['content']['bean']);
    // Check the bundle and look for the reference.
    if ($bean['#bundle'] == 'list_block' && !isset($bean['field_nems_block_reference'])) {
      $data['subject'] = '';
      $data['content'] = '';
    }
  }
}

/**
 * Custom access function to restrict the access to bartik and seven.
 *
 * @param object $theme
 *   Object containing theme data.
 *
 * @return bool
 *   Access rights edit result.
 */
function _nems_core_block_themes_access($theme) {

  if ($theme->name == 'bartik' || $theme->name == 'seven') {
    global $user;
    if (in_array('administrator', array_values($user->roles))) {
      return TRUE;
    }
    else {
      return FALSE;
    }
  }
  else {
    return _block_themes_access($theme);
  }
}

/**
 * Restrict access to administrator and superuser accounts.
 *
 * @param object $account
 *   Object containing account data.
 *
 * @return bool
 *   Access rights edit result.
 */
function _nems_core_user_edit_access($account) {
  global $user;
  // Restrict access to user 1 account.
  if ($account->uid == 1 and $user->uid != 1) {
    return FALSE;
  }
  if (in_array('administrator', $account->roles) && !in_array('administrator', $user->roles)) {
    return FALSE;
  }
  return user_edit_access($account);
}

/**
 * Callback for the admin page.
 */
function nems_core_sync_folders_form() {
  $form['description'] = array(
    '#type' => 'markup',
    '#markup' => t('Parse files and folders to sync with MBP'),
  );
  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => 'Go',
  );

  return $form;
}

/**
 * Submit handler for nems_core_sync_folders_form().
 */
function nems_core_sync_folders_form_submit($form, &$form_state) {
  $operations = array();

  // Fetch all unassigned files.
  // EntityFieldQuery does not know NULL.
  $query = db_select('file_managed', 'fm');
  $query->leftJoin('field_data_field_folder', 'ff', 'fm.fid = ff.entity_id');
  $query->fields('fm', array('fid'));
  $query->fields('ff', array('field_folder_tid'));
  $query->condition('field_folder_tid', NULL);
  $result = $query->execute()->fetchAllAssoc('fid');
  // Break them into chunks.
  $fids = array_keys($result);
  $chunks = array_chunk($fids, 10);

  foreach ($chunks as $chunk) {
    $operations[] = array('_nems_core_sync_folders_form_op', array(
      $chunk,
    ),
    );
  }

  $batch = array('operations' => $operations, 'finished' => '_nems_core_sync_folders_form_finished');

  batch_set($batch);
}

/**
 * Process barches of files and create/assign terms.
 *
 * @param array $chunk
 *   Chunks of file ids.
 * @param array $context
 *   Batch context.
 */
function _nems_core_sync_folders_form_op($chunk, &$context) {
  $files = entity_load('file', array($chunk));

  foreach ($files as $file) {
    $uri = str_replace(array('public://', 'private://'), '', $file->uri);
    // Remove file name.
    $uri = rtrim($uri, '/');
    $uri = explode('/', $uri);
    array_pop($uri);
    $uri = implode('/', $uri);
    // Get media_folders term id for that path.
    $tid = _nems_core_get_media_folder_tid($uri, $context);
    // Add the folder media tid.
    if (!empty($tid)) {
      $wrapper = entity_metadata_wrapper('file', $file);
      $wrapper->field_folder->set($tid);
      $wrapper->save();
    }
  }
}

/**
 * Get media folder term id.
 *
 * @param string $dir
 *   Directory path.
 * @param array $context
 *   Batch context.
 *
 * @return int $tid
 *   The found term id.
 */
function _nems_core_get_media_folder_tid($dir, &$context) {
  // Check if term or any parent exist
  // starting from current file folder (not parent).
  $reps = drupal_map_assoc(array_reverse(explode("/", $dir)));

  // File is a direct child of media root.
  if (empty($reps)) {
    $root = taxonomy_get_term_by_name(NEMS_CORE_MBP_MEDIA_FOLDER_ROOT, NEMS_CORE_MBP_MEDIA_FOLDER_VOCABULARY);

    return $root->tid;
  }

  foreach ($reps as $rep) {
    $tls = taxonomy_get_term_by_name($rep, NEMS_CORE_MBP_MEDIA_FOLDER_VOCABULARY);
    // If term is found, check that the parents are the same.
    if (count($tls)) {
      // Extract only the ancestors of current found item.
      $pos = array_search($rep, array_keys($reps));

      if ($pos == 0) {
        // It does not have parents.
        $tl = array_shift($tls);
        return $tl->tid;
      }

      $ancestors = implode("/", array_reverse(array_slice($reps, $pos)));
      foreach ($tls as $tl) {
        if (_nems_core_get_media_folder_parents_path($tl, $ancestors)) {
          // An common ancestor has been found.
          $to_create = str_replace($ancestors, '', $dir);
          // If needed, create children based on that parent.
          $tid = !empty($to_create) ? _nems_core_create_media_folder($to_create, $tl) : $tl->tid;
          // Exit both loops.
          break 2;
        }
      }
    }
  }
  // On that point we do not have any known ancestor, create the whole tree.
  if (empty($tid)) {
    $root = taxonomy_get_term_by_name(NEMS_CORE_MBP_MEDIA_FOLDER_ROOT, NEMS_CORE_MBP_MEDIA_FOLDER_VOCABULARY);
    $tid = _nems_core_create_media_folder($dir, reset($root));
  }

  return $tid;
}

/**
 * Get ancestors of current term.
 *
 * @param object $kid
 *   The term looked up for.
 * @param string $ancestors
 *   The path of parents.
 *
 * @return bool
 *   Result.
 */
function _nems_core_get_media_folder_parents_path($kid, $ancestors) {
  // Reverse the parents and remove the Media Root.
  $parents = array_reverse(taxonomy_get_parents_all($kid->tid));
  array_shift($parents);
  $par = array();
  foreach ($parents as $parent) {
    $par[] = $parent->name;
  }
  if ($ancestors == implode("/", $par)) {
    return TRUE;
  }
  return FALSE;
}

/**
 * Create media folder term.
 *
 * @param string $tree
 *   The path "tree" to the file.
 * @param object $parent
 *   The term parent.
 *
 * @return int
 *   The term id.
 */
function _nems_core_create_media_folder($tree, $parent) {
  // Create the 1st child on the parent
  // and other on their parent created on the fly.
  $current_parent = $parent->tid;
  $vocab = taxonomy_vocabulary_machine_name_load(NEMS_CORE_MBP_MEDIA_FOLDER_VOCABULARY);
  $to_create = explode('/', $tree);
  foreach ($to_create as $tc) {
    if (!empty($tc)) {
      $term = (object) array(
        'name' => $tc,
        'vid' => $vocab->vid,
        'parent' => array($current_parent),
      );
      taxonomy_term_save($term);
      $current_parent = $term->tid;
    }
  }
  // Return the tid of the folder of the file.
  return $term->tid;
}

/**
 * Show status message of batch.
 *
 * @param bool $success
 *   The batch status.
 * @param array $results
 *   Processed operations results.
 * @param array $operations
 *   The operations passed to batch.
 */
function _nems_core_sync_folders_form_finished($success, $results, $operations) {
  if ($success) {
    // We need a flush to display the new tid values on the file forms.
    cache_clear_all();
    drupal_set_message(t('Success.'));
  }
  else {
    // An error occurred.
    // $operations contains the operations that remained unprocessed.
    $error_operation = reset($operations);
    $message = t('An error occurred while processing @operation with arguments : @args', array(
      '@operation' => $error_operation[0],
      '@args' => print_r($error_operation[0], TRUE),
    )
    );
    drupal_set_message($message, 'error');
  }
}
